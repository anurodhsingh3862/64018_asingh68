---
title: "DEA-ASSIGNMENT-QMM-03"
author: "ANURODH-SINGH"
date: "2023-11-03"
output:
  pdf_document: default
  html_document: default
---
# CONCLUSION

'T_output' variable table shows that the 3 resultant peers or frontiers or boundary conditions for each energy policy are obtained as a 3-dimensional reference following x, y, and z axis, depending on the inputs ("D.C size" and "#Shutdowns") and outputs ("Computing Time(h)", "MWh Consumed", and "Queue time(ms)").

DEA analysis results show that the efficiencies for all 18 energy policies are [1.0000 1.0000 0.9991 0.4818 1.0000 0.4872 1.0000 0.9826 0.9578 1.0000 0.9806 0.4754 1.0000 0.9944 1.0000 0.9970 0.5290 0.4783] respectively. This means that 7 energy policies are 100% efficient and will be treated as the frontiers or boundary conditions, while the other 11 need to improve their performance.

The following table shows the amount/percentage of improvement required by each inefficient energy policy:

Energy Policy	Amount/Percentage of Improvement Required
3 Gamma Omega High 0.09%          
4 Always Mono. Low 51.82%          
6 Load Omega Low   51.28%         
8 Gamma Mono. High  1.74%       
9 Random Mesos High 4.22%        
11 ExponentialOmega High 1.94%   
12 Margin Omega Low  52.46%        
14 Gamma Mono. High  0.56%       
16 Gamma Omega High  0.3%       
17 Gamma Mesos Low   47.1%       
18 Random Omega Low  52.17%       
The amount/percentage of improvement using the peers energy policies is found out using the lambda function with Constant Return to scale (CRS), which is the biggest umbrella. This is stored in the 'CRS_Weights' variable.

The result implies that for example if energy policy "8 Gamma Mono. High" is chosen then it needs to learn or follow around 22.1% of energy policy "2 Margin Mesos High", 59.15% of energy policy "10 Margin Omega High", and 17.35% of energy policy "13 Margin Mono. High". The same applies to other policies as well.

In other words, energy policy "8 Gamma Mono. High" can improve its performance by learning from the best practices of energy policies "2 Margin Mesos High", "10 Margin Omega High", and "13 Margin Mono. High".

*******

# SUMMARY


•	First of all The library "Benchmarking" is installed.

•	Then two matrices, 'x' and 'y', are created and combined using the 'cbind' function.

•	'x' contains data related to data center size and shutdowns.

•	'y' contains data related to computing time, MWh consumption, and queue time.

•	Row names are assigned to 'T_output' for data point identification.

•	'T_output' is printed to display the combined data.

•	DEA (Data Envelopment Analysis) is conducted on 'x' and 'y' using the 'dea' function with the      "RTS" parameter set to "crs" for Constant Returns to Scale.

•	Efficiency scores generated by DEA are printed using the 'print' function.

•	The 'peers' function is utilized to identify peers for each data point based on relative           efficiency scores.

•	Efficiency scores for each data point are extracted and stored in the 'CRS_Weights' variable       using the 'lambda' function

********

```{r setup, include=FALSE, hide=TRUE, results='hide'}
knitr::opts_chunk$set(echo = TRUE)
```

#Installing required packages

```{r}
#install.packages("Benchmarking")
library(Benchmarking)

```
```{r}
# Create matrices with the same number of rows
x <- matrix(c(1000, 1000, 1000, 1000, 1000, 1000, 5000, 5000, 5000, 5000, 5000, 5000, 10000, 10000, 10000, 10000, 10000, 10000,37166,13361,14252,36404,19671,32407,6981,9877,33589,8578,11863,15452,9680,11388,18150,18409,29707,40772), ncol = 2)
y <- matrix(c(104.42, 104.26, 104.17, 49.25, 49.63, 49.34, 99.96, 99.96, 100.03, 100.26, 100.26, 46.7, 101.56, 101.56, 101.63, 101.63, 45.83, 46.09, 49.01, 49.65, 49.6, 23.92, 24.65, 24.19, 237.09, 235.92, 234.9, 239.13, 236.95, 115.82, 481.36, 479.36, 486.11, 484.69, 228.31, 233.5, 90.1, 1093, 0.1, 78.3, 1188.7, 1.1, 126.2, 129.8, 1122.6, 0.7, 1, 0.5, 325.2, 327.9, 2.6, 2.5, 1107.6, 3.8), ncol = 3)

colnames(y) <- c("Computing Time(h)", "MWh Consumed", "Queue time(ms)")
colnames(x) <- c("D.C size", "#Shutdowns")

print(x) # Print the values of 'X'
print(y) # Print the values of 'Y'

# Assuming the matrices 'x' and 'y' have the same number of rows, you can cbind them
T_output <- cbind(x, y)
row.names(T_output) <- c("1 Always Monolithic High", "2 Margin Mesos High", "3 Gamma Omega High", "4 Always Mono. Low", "5 ExponentialMesos Low", "6 Load Omega Low", "7 Margin Mono. High", "8 Gamma Mono. High", "9 Random Mesos High", "10 Margin Omega High", "11 ExponentialOmega High", "12 Margin Omega Low", "13 Margin Mono. High", "14 Gamma Mono. High", "15 Margin Omega High", "16 Gamma Omega High", "17 Gamma Mesos Low", "18 Random Omega Low")

T_output

```
```{r}
CRS <- dea(x,y, RTS = "crs")
print(CRS)

peers(CRS)
CRS_Weights <- lambda(CRS)
CRS_Weights

```



